{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Olympix","text":"<p>Welcome to the official Olympix documentation! Here you'll find everything you need to get started with our CLI, test generation tools, and integrated security features. Whether you're setting up your environment, scanning for vulnerabilities, or automating test generation, our documentation provides clear instructions and detailed examples.</p> <p>Visit our Website: Explore more about Olympix and our solutions at olympix.ai.</p> <p>Detector Documentation: For in-depth information on our vulnerability detectors, check out the Detector Documentation.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li> <p>Installation   Get started with downloading and installing the Olympix CLI and VSCode extension.</p> </li> <li> <p>CLI   Learn about the Olympix CLI commands, options, and usage examples to integrate into your workflow.</p> </li> <li> <p>GitHub Actions   Learn about GitHub Actions integrations provided by Olympix.</p> </li> <li> <p>VSCode Extension   Learn about Olympix's features integrated directly into your editor, including real-time scanning and automatic quick fixes.</p> </li> </ul> <p>Happy exploring, and feel free to reach out to us at contact@olympix.ai if you have any questions or need support.</p>"},{"location":"ConfigOptions/","title":"Configuration and Ignore Options","text":""},{"location":"ConfigOptions/#overview","title":"Overview","text":"<p>Olympix tools can be configured using a JSON file at the root of your repository. This allows you to fine-tune the analysis by ignoring specific vulnerabilities, files, or paths, and by marking certain contracts, variables, and paths as \"trusted.\"</p>"},{"location":"ConfigOptions/#file-structure","title":"File Structure","text":"<p>The <code>olympix-config.json</code> file follows the structure below. All paths should be relative to the project root.</p> <pre><code>{\n    \"IgnoredVulnerabilities\" : {\n        \"&lt;DETECTOR-SLUG&gt;\" : {\n            \"&lt;FILENAME&gt;\" : [&lt;LINENUM&gt;, ...]\n        }, ...\n    },\n    \"IgnoredPaths\" : [\n        \"&lt;PATH_PATTERN&gt;\",\n        ...\n    ],\n    \"TrustedVariables\": {\n        \"&lt;DETECTOR-SLUG&gt;\" : {\n            \"&lt;FILENAME&gt;\" : [&lt;LINENUM&gt;, ...]\n        }, ...\n    },\n    \"TrustedContracts\": {\n        \"&lt;DETECTOR-SLUG&gt;\" : [\"&lt;CONTRACT_NAME&gt;\", ...]\n    },\n    \"TrustedPaths\": [\n        \"&lt;PATH_PATTERN&gt;\",\n        ...\n    ]\n}\n</code></pre>"},{"location":"ConfigOptions/#key-explanations","title":"Key Explanations","text":"<ul> <li> <p><code>IgnoredVulnerabilities</code>: A dictionary to ignore specific vulnerability types.</p> <ul> <li><code>&lt;DETECTOR-SLUG&gt;</code>: The unique identifier for the vulnerability (e.g., <code>reentrancy</code>). You can get a list of all slugs by running the <code>olympix show-vulnerabilities</code> command.</li> <li><code>&lt;FILENAME&gt;</code>: The path to the file containing the vulnerability.</li> <li><code>[&lt;LINENUM&gt;, ...]</code>: An array of line numbers in that file to ignore for that specific vulnerability.</li> </ul> </li> <li> <p><code>IgnoredPaths</code>: An array of filepaths or directory paths to completely exclude from the analysis. The analyzer will ignore any file path that starts with one of the provided patterns.</p> </li> <li> <p><code>TrustedPaths</code>: An array of filepaths that should be considered trusted. This can help reduce the severity or number of reported issues from known safe code, such as audited third-party libraries.</p> </li> <li> <p><code>TrustedVariables</code>: A dictionary used to mark specific variables (at specific lines) as trusted for a given check. This is particularly useful for silencing findings like <code>unfuzzed-variables</code> where a variable is intentionally left in a certain state. The structure is identical to <code>IgnoredVulnerabilities</code>.</p> </li> <li> <p><code>TrustedContracts</code>: A dictionary used to mark entire contracts as trusted for a specific detector. This is useful when a contract's design is known to be safe against a particular vulnerability (e.g., a contract that is non-reentrant by design).</p> </li> </ul>"},{"location":"ConfigOptions/#example","title":"Example","text":"<p>Here is an example <code>olympix-config.json</code> file demonstrating how to use the different options:</p> <pre><code>{\n  \"IgnoredVulnerabilities\": {\n    \"reentrancy\" : {\n      \"src/reentrancy/CEI.sol\" : [21]\n    },\n    \"locked-ether\": {\n      \"src/reentrancy/CEILib.sol\" : [32]\n    }\n  },\n  \"TrustedVariables\": {\n    \"unfuzzed-variables\" : {\n      \"src/unfuzzed-state-variables/main.sol\" : [5]\n    }\n  },\n  \"TrustedContracts\": {\n    \"reentrancy\" : [\"ChecksEffectsInteractionsNamespacedLibContract\"]\n  },\n  \"IgnoredPaths\": [\"src/signature-replay/\"],\n  \"TrustedPaths\": [\"src/low-level-call-parameters-verified/\"]\n}\n</code></pre>"},{"location":"ConfigOptions/#info","title":"info","text":"<ul> <li>The configuration file must be located at the workspace root.</li> <li>It supports multiple detector slugs, files, contracts, and line numbers.</li> <li>The settings apply across all Olympix tools.</li> </ul>"},{"location":"ConfigOptions/#usage","title":"Usage","text":"<p>To use these features, ensure that:</p> <ol> <li>The <code>olympix-config.json</code></li> <li>The specified detector slugs, filenames, and line numbers match the vulnerability reports.</li> </ol>"},{"location":"ConfigOptions/#note","title":"Note","text":"<p>The original <code>.olympix-ignore.json</code> file is still supported for ignoring vulnerabilities and paths.</p> <p>If both files are present, their configurations will be merged. The tools will recognize any of these filenames at your project's root: * <code>olympix-config.json</code> * <code>.olympix-config.json</code> * <code>.olympix-ignore.json</code></p> <p>!!! Warning Be extra-confident before disabling any vulnerabilities, as this could allow bugs to silently pass into production\u2014bugs that might not even exist yet. Ignoring vulnerabilities should only be done after a thorough review to ensure that it does not introduce security risks in the future.</p>"},{"location":"IgnoreOptions/","title":"Ignore File","text":""},{"location":"IgnoreOptions/#overview","title":"Overview","text":"<p>The <code>.olympix-ignore.json</code> file allows users to specify which vulnerabilities should be ignored in specific files and lines within their repository. This file must be placed at the root of the repository to be recognized and applied across all tools.</p>"},{"location":"IgnoreOptions/#file-structure","title":"File Structure","text":"<p>The <code>.olympix-ignore.json</code> file follows a structured JSON format as shown below:</p> <pre><code>{\n    \"IgnoredVulnerabilities\" : {\n        \"&lt;DETECTOR-SLUG&gt;\" : {\n            \"&lt;FILENAME&gt;\" : [&lt;LINENUM&gt;, ...]\n        }, ...\n    },\n    \"IgnoredPaths\" : [\n        \"&lt;PATH_PATTERN&gt;\",\n        ...\n    ]\n}\n</code></pre>"},{"location":"IgnoreOptions/#explanation","title":"Explanation:","text":"<ul> <li><code>IgnoredVulnerabilities</code>: A dictionary where each key is a detector slug representing a specific vulnerability type.<ul> <li><code>&lt;DETECTOR-SLUG&gt;</code>: A string representing the detector slug, e.g., <code>abi-encode-packed-dynamic-types</code>. You can get the slug by running the <code>olympix show-vulnerabilities</code> command in the CLI.</li> <li><code>&lt;FILENAME&gt;</code>: The path to the file where the vulnerability is ignored.</li> <li><code>[&lt;LINENUM&gt;, ...]</code>: An array of line numbers in the specified file where the vulnerability is ignored.</li> </ul> </li> </ul> <ul> <li><code>IgnoredPaths</code>: An array of filepaths that specify what all paths should the analyzer ignore. <ul> <li>For each of the entries in the array, the analyzer will ignore any filepaths that start with that entry. (1)</li> </ul> </li> </ul> <ol> <li>Each entry can be thought of as the following regex: <code>^ENTRY.*</code>, where the string <code>ENTRY</code> is replaced with each entry in the provided array. Any file matching any of these regexes would be ignored. Hence, these paths can be partial paths too, the asterisk at the end is implied, no wildcards are allowed. </li> </ol> <p>Note</p> <p>All paths in this file should be relative from the project root (and should not start with a <code>/</code>).</p>"},{"location":"IgnoreOptions/#example","title":"Example","text":"<p>Here is an example <code>.olympix-ignore.json</code> file:</p> <pre><code>{\n    \"IgnoredVulnerabilities\" : {\n        \"abi-encode-packed-dynamic-types\" : {\n            \"src/contracts/FraxlendPairDeployer.sol\" : [255, 300, 450],\n            \"src/contracts/AnotherContract.sol\" : [120, 180]\n        },\n        \"reentrancy\" : {\n            \"src/contracts/SafeContract.sol\" : [75, 150, 225],\n            \"src/contracts/CriticalModule.sol\" : [90, 200]\n        }\n    },\n    \"IgnoredPaths\": [\n        \"src/contracts/external\",\n        \"src/contracts/vendors\",\n        \"src/contracts2/DontScanMe.sol\"\n    ]\n}\n</code></pre> <p>Info</p> <ul> <li>The file must be located at the workspace root.</li> <li>It supports multiple detector slugs, files, and line numbers.</li> <li>This ignore file applies across all Olympix tools.</li> </ul>"},{"location":"IgnoreOptions/#ignore-comment","title":"Ignore Comment","text":"<p>In any line of your code that you want to be ignore by the analyzer, you can add the following comments:</p> <ol> <li><code>//#olympix-ignore</code> - This will disable this line for all detectors.</li> <li><code>//#olympix-ignore-&lt;DETECTOR-SLUG&gt;</code> - This will only disable that detector for that line.</li> </ol>"},{"location":"IgnoreOptions/#usage","title":"Usage","text":"<p>To effectively ignore vulnerabilities, ensure that:</p> <ol> <li>The file is committed to the repository root.</li> <li>The specified detector slugs, filenames, and line numbers match the vulnerability reports.</li> </ol>"},{"location":"IgnoreOptions/#note","title":"Note","text":"<p>The ignore file will soon be deprecated, plese refer to the <code>ConfigOptions</code> section to use the most up to date version.</p> <p>Warning</p> <p>Be extra-confident before disabling any vulnerabilities, as this could allow bugs to silently pass into production\u2014bugs that might not even exist yet. Ignoring vulnerabilities should only be done after a thorough review to ensure that it does not introduce security risks in the future.</p>"},{"location":"Installation/","title":"Installation Guide","text":"<p>Welcome to the Olympix installation guide! Get started by installing the CLI and the VSCode extension to access all of Olympix\u2019s powerful features. This guide covers the full process\u2014from downloading the CLI binaries to authenticating your account.</p>"},{"location":"Installation/#cli-installation","title":"CLI Installation","text":""},{"location":"Installation/#option-1-download-the-olympix-cli-from-the-cli-webpage","title":"Option 1: Download the Olympix CLI from the CLI webpage","text":"<p>Visit the Olympix CLI webpage and scroll down to the Download section. Here, you\u2019ll find precompiled binaries for various platforms, including macOS, Linux, and Windows (both x64 and ARM architectures).</p>"},{"location":"Installation/#option-2-get-it-directly-from-the-terminal","title":"Option 2: Get it directly from the terminal","text":"<p>For example, to install on macOS (ARM64), run the following commands in your terminal:</p> <p>Note</p> <p>The following versions are available: (osx-arm64, osx-x64, win-x64, win-arm64, linux-x64, linux-arm64)</p> osx-arm64osx-x64win-arm64win-x64linux-arm64linux-x64 <pre><code>curl -o olympix https://olympix-download.s3.amazonaws.com/cli/v0.9.70/osx-arm64/olympix\nchmod +x olympix\n./olympix login -e user@olympix.ai\n</code></pre> <pre><code>curl -o olympix https://olympix-download.s3.amazonaws.com/cli/v0.9.70/osx-x64/olympix\nchmod +x olympix\n./olympix login -e user@olympix.ai\n</code></pre> <pre><code>curl -o olympix https://olympix-download.s3.amazonaws.com/cli/v0.9.70/win-arm64/olympix.exe\nchmod +x olympix\n./olympix login -e user@olympix.ai\n</code></pre> <pre><code>curl -o olympix https://olympix-download.s3.amazonaws.com/cli/v0.9.70/win-x64/olympix.exe\nchmod +x olympix\n./olympix login -e user@olympix.ai\n</code></pre> <pre><code>curl -o olympix https://olympix-download.s3.amazonaws.com/cli/v0.9.70/linux-arm64/olympix\nchmod +x olympix\n./olympix login -e user@olympix.ai\n</code></pre> <pre><code>curl -o olympix https://olympix-download.s3.amazonaws.com/cli/v0.9.70/linux-x64/olympix\nchmod +x olympix\n./olympix login -e user@olympix.ai\n</code></pre> <p>Setting Permissions on Unix-like Systems</p> <p>On macOS and Linux, ensure you grant execution permissions to the binary using <code>chmod +x</code>. If you receive a warning that the binary is from an unidentified developer, do the following: - Open System Preferences \u2192 Security &amp; Privacy. - Click the General tab. - Select Open Anyway next to the warning message.</p> <p>Setting Permissions on Windows</p> <p>For Windows users, download the appropriate binary from the download page and follow these steps: - Download the <code>.exe</code> binary matching your Windows architecture. - Run the binary from the command prompt. - If needed, set the executable permissions through file properties.</p>"},{"location":"Installation/#authentication","title":"Authentication","text":"<p>After downloading and setting up the CLI, authenticate your account by following these steps:</p> <ol> <li> <p>Run the login command:    Execute <code>./olympix login -e your_email@domain.com</code> in your terminal.</p> </li> <li> <p>Enter the one-time code:    You will receive a one-time code on your email. Enter it in the terminal prompt to complete authentication.</p> </li> <li> <p>Capture your API token:    Once authenticated, your Olympix API token is displayed. Save it securely as it is required for integration with other services, such as GitHub Actions. (This token is also automatically stored in <code>~/.opix/config.json</code> )</p> </li> </ol> <p>Need to Register Additional Emails?</p> <p>If you need to register more email addresses for your organization, please email contact@olympix.ai.</p>"},{"location":"Installation/#vscode-extension","title":"VSCode Extension","text":"<p>Our extension is available in the VSCode Marketplace. Install it to integrate Olympix features directly into your development environment.</p>"},{"location":"Installation/#additional-resources","title":"Additional Resources","text":"<ul> <li>Olympix CLI Documentation: Visit the CLI documentation page for complete command reference and troubleshooting tips.</li> <li>YouTube Tutorial: For a video walkthrough of the setup and usage, watch our YouTube tutorial.</li> </ul> <p>If you encounter any issues or have questions, feel free to reach out to our support team at contact@olympix.ai.</p>"},{"location":"CLI/","title":"Getting Started","text":"<p>Welcome to the Olympix CLI usage guide! This guide will help you quickly get started with the command-line interface for the Olympix Static Analyzer and Test Generator.</p>"},{"location":"CLI/#cli-commands-overview","title":"CLI Commands Overview","text":"<p>When you run the Olympix CLI, you have access to several commands:</p> <ul> <li><code>analyze</code>: Perform code analysis  </li> <li><code>generate-unit-tests</code>: Generate unit tests  </li> <li><code>generate-mutation-tests</code>: Generate mutation tests  </li> <li><code>login</code>: Request access and log in to your account  </li> <li><code>show-vulnerabilities</code>: Show the vulnerability types that the analyzer aims to find  </li> <li><code>version</code>: Show CLI version</li> </ul>"},{"location":"CLI/#analysis-options","title":"Analysis Options","text":"<p>When using the <code>analyze</code> command, you can customize the analysis with the following options:</p> <ul> <li> <p><code>-w | --workspace-path</code>   Defines the root project directory path. This helps in providing more accurate vulnerability analysis. Default: current directory</p> </li> <li> <p><code>-p | --path</code>   Defines the Solidity project directory path to be analyzed. Can be used multiple times. Default: <code>'contracts'</code> and <code>'src'</code> directories if they exist, otherwise the workspace directory</p> </li> <li> <p><code>-f | --output-format</code>   Defines the result output format. Supported formats: <code>tree</code>, <code>json</code>, <code>sarif</code>, <code>email</code>. Default: <code>tree</code></p> </li> <li> <p><code>-o | --output-path</code>   Defines the result output directory path (enabled only for <code>json</code> and <code>sarif</code> formats). Default: Results are shown directly in the terminal</p> </li> <li> <p><code>--no-&lt;vulnerability id&gt;</code>   Defines the vulnerabilities to be ignored. Can be used multiple times. Default: Ignores nothing</p> </li> </ul>"},{"location":"CLI/#unit-tests-generation-options","title":"Unit Tests Generation Options","text":"<p>When generating unit tests, you can use these options:</p> <ul> <li> <p><code>-w | --workspace-path</code> Defines the root project directory path. Default: current directory</p> </li> <li> <p><code>-env | --include-dot-env</code>: If included, sends the env file data along with smart contracts (This is to pass secrets such as private keys/RPC urls/API keys etc. which are often need for fork testing). To specify a custom env file, include the --env-file argument.</p> </li> <li> <p><code>--env-file</code>: Defines the path of the file containing the environment variables. Make sure to follow foundry's .env format guidelines. Doesn't do anything if '--include-dot-env' is not set.   Default: <code>.env</code></p> </li> <li> <p><code>-ext, --extension</code>: This allows you to specify additional file extensions to be included in the analysis. You can use this option multiple times to add more extensions. For example: <code>--extra-extension .json --extra-extension .txt</code>. By default, only <code>.sol/.t.sol</code> and/or <code>foundry.toml</code> files are uploaded.</p> </li> <li> <p><code>-ca | --confirm-all</code>   Confirm as 'yes' for all interactive questions.</p> </li> </ul>"},{"location":"CLI/#mutation-tests-generation-options","title":"Mutation Tests Generation Options","text":"<p>When generating mutation tests, you have the following options:</p> <ul> <li> <p><code>-w | --workspace-path</code>   Defines the root project directory path. Default: current directory</p> </li> <li> <p><code>-p | --path</code>   Defines the Solidity file path to run the mutation tests. Can be used multiple times.</p> </li> <li> <p><code>-t | --timeout</code>   Sets a timeout (in seconds) for each mutant. This prevents infinite loops or hangs. Default: 300 seconds Allowed Range: 10 - 500 seconds</p> </li> <li> <p><code>-env | --include-dot-env</code>: If included, sends the env file data along with smart contracts (This is to pass secrets such as private keys/RPC urls/API keys etc. which are often need for fork testing). To specify a custom env file, include the --env-file argument.</p> </li> <li> <p><code>--env-file</code>: Defines the path of the file containing the environment variables. Make sure to follow foundry's .env format guidelines. Doesn't do anything if '--include-dot-env' is not set.   Default: <code>.env</code></p> </li> <li><code>-ext, --extension</code>: This allows you to specify additional file extensions to be included in the analysis. You can use this option multiple times to add more extensions. For example: <code>--extra-extension .json --extra-extension .txt</code>. By default, only <code>.sol/.t.sol</code> and/or <code>foundry.toml</code> files are uploaded.</li> </ul>"},{"location":"CLI/#usage-examples","title":"Usage Examples","text":"<pre><code># Analyze command\nanalyze [-w | --workspace-path &lt;workspace directory&gt;] [-p | --path &lt;analysis directory&gt;] [-f | --output-format &lt;output format&gt;] [-o | --output-path &lt;output directory&gt;] [--no-&lt;vulnerability id&gt;]\n\n# Generate unit tests\ngenerate-unit-tests [-w | --workspace-path &lt;workspace directory&gt;] [-ca | --confirm-all] [-env | --include-dot-env] [--env-file &lt;env file path&gt;] [-ext | --extension .&lt;extension-to-include&gt;]\n\n# Generate mutation tests\ngenerate-mutation-tests [-w | --workspace-path &lt;workspace directory&gt;] [-p | --path &lt;solidity file path&gt;] [-t | --t &lt;timeout&gt;] [-env | --include-dot-env] [--env-file &lt;env file path&gt;] [-ext | --extension .&lt;extension-to-include&gt;]\n\n# Login\nlogin [-e | --email &lt;user email&gt;]\n</code></pre>"},{"location":"CLI/#helpful-links","title":"Helpful Links","text":"<ul> <li> <p>Installation   Get started by installing the CLI binaries and the VSCode extension.</p> </li> <li> <p>Unit Test Generation   Learn how to generate unit tests for your smart contracts using the Olympix Unit Test Generator.</p> </li> <li> <p>Mutation Tests Generation   Find out how to generate mutation tests to assess your unit test quality.</p> </li> </ul> <p>With these commands and options at your disposal, you're well-equipped to leverage Olympix for efficient static analysis and robust test generation. If you have any questions, our support team is ready to help at contact@olympix.ai.</p>"},{"location":"CLI/Analysis/","title":"Analysis","text":"<p>This section covers how to perform static analysis using the Olympix CLI and explains the various reporting strategies available.</p>"},{"location":"CLI/Analysis/#finding-vulnerabilities-via-cli","title":"Finding Vulnerabilities via CLI","text":"<p>The Olympix CLI allows you to scan your Solidity projects for vulnerabilities quickly and effectively. To get started, navigate to the root directory of your project and run the analysis command. This will inspect your code for known vulnerability patterns.</p> <p>Quick Start</p> <p>Run the following command in your terminal from the project root:</p> <pre><code>olympix analyze\n</code></pre> <p>Depending on your project\u2019s structure, the CLI will automatically look for all Solidity files in your root directory. You can also explicitly specify additional directories using the <code>-p</code> or <code>--path</code> option.</p> <p>The <code>analyze</code> command is designed to help you: - Identify vulnerabilities: The tool checks for a wide range of issues such as uninitialized state variables, default visibility problems, and other common pitfalls. - Customize your scan: Use options to narrow down the directories, exclude certain vulnerability checks, or alter the output format.</p> <p>These features ensure that you can integrate the analyzer into your development workflow or CI/CD pipeline, receiving feedback directly in your terminal or exported to files for further inspection :contentReference[oaicite:0]{index=0}.</p>"},{"location":"CLI/Analysis/#reporting-strategies-via-cli","title":"Reporting Strategies via CLI","text":"<p>Once the analysis is complete, Olympix offers several ways to view and export the results. The CLI supports four output formats:</p>"},{"location":"CLI/Analysis/#option-1-tree","title":"Option 1: Tree","text":"<ul> <li>Description: The results are displayed directly in your terminal in a structured tree format.</li> <li>When to Use: Ideal for a quick overview during development.</li> <li>Default: This is the default output format if no other option is specified.</li> </ul>"},{"location":"CLI/Analysis/#option-2-json","title":"Option 2: JSON","text":"<ul> <li>Description: Outputs the results as JSON data.</li> <li>Usage: Useful when integrating the results into automated tools or further processing.</li> <li>Additional Option: Use the <code>-o</code> or <code>--output-path</code> option to write the JSON output to a file.</li> </ul>"},{"location":"CLI/Analysis/#option-3-sarif","title":"Option 3: SARIF","text":"<ul> <li>Description: Outputs the analysis results in SARIF (Static Analysis Results Interchange Format).</li> <li>When to Use: Particularly beneficial if you wish to integrate with GitHub\u2019s Code Scanning tools or other security platforms.</li> <li>Additional Option: Use the <code>-o</code> or <code>--output-path</code> option to specify the output file location.</li> </ul>"},{"location":"CLI/Analysis/#option-4-email","title":"Option 4: Email","text":"<ul> <li>Description: Sends the analysis results in a tabular format directly to your registered email address.</li> <li>When to Use: Great for receiving detailed reports without needing to navigate the terminal output.</li> </ul> <p>Choosing a Reporting Strategy</p> <p>Your choice of reporting format depends on your workflow. For a quick local review, the tree format works well. If you need to integrate the results with other tools or share them with a team, JSON, SARIF, or email options might be more appropriate.</p> <p>These reporting strategies are designed to cater to both manual review and automated processing, giving you flexibility in how you manage and respond to vulnerability findings.</p>"},{"location":"CLI/Mutation%20Testing/","title":"Mutation Test Generation","text":""},{"location":"CLI/Mutation%20Testing/#overview","title":"Overview","text":"<p>Mutation testing is a powerful technique for evaluating the effectiveness of your test suite by introducing small, systematic modifications (mutations) to your source code and verifying if your tests can detect these changes. While code coverage tells you what lines of code are executed by your tests, mutation testing tells you how effective your tests are at catching actual bugs.</p>"},{"location":"CLI/Mutation%20Testing/#why-mutation-testing-matters","title":"Why Mutation Testing Matters","text":"<p>Traditional metrics like code coverage can provide a false sense of security. Having 100% coverage doesn't necessarily mean your tests are meaningful\u2014they might assert the wrong things or have weak assertions. Mutation testing provides a more meaningful metric by:</p> <ol> <li>Measuring test suite effectiveness over time  </li> <li>Identifying areas where tests might be insufficient  </li> <li>Forcing developers to write more thorough assertions  </li> <li>Discovering edge cases that weren't previously considered  </li> </ol>"},{"location":"CLI/Mutation%20Testing/#security-implications","title":"Security Implications","text":"<p>In blockchain and smart contract development, mutation testing is particularly crucial for security. Many historical smart contract hacks occurred due to seemingly minor changes in business logic that weren't caught by existing test suites. Our mutation operators are specifically derived from real-world smart contract exploits\u2014each mutation pattern in our tool corresponds to actual changes that led to significant security breaches in production contracts.</p>"},{"location":"CLI/Mutation%20Testing/#installation-requirements","title":"Installation &amp; Requirements","text":"<p>The mutation test generator is designed to be dependency-free and works with any Forge project. The only prerequisite is having a Forge project with unit tests.</p> <p> No external dependencies  Works with standard Forge unit tests out of the box.</p>"},{"location":"CLI/Mutation%20Testing/#cli-usage","title":"CLI Usage","text":"<pre><code>generate-mutation-tests [-w &lt;workspace&gt;] [-p &lt;solidity-file&gt;] [-t &lt;timeout&gt;]\n\nOptions\n    -w, --workspace-path: Root project directory path (default: current directory)\n    -p, --path: Solidity file path to mutate (can be specified multiple times)\n    -t, --timeout: Timeout in seconds for each mutant test run (default: 300s, range: 10-500s)\n    -env, --include-dot-env: If included, sends the env file data along with smart contracts (This is to pass secrets such as private keys/RPC urls/API keys etc. which are often need for fork testing). To specify a custom env file, include the --env-file argument.\n    --env-file: Defines the path of the file containing the environment variables. Make sure to follow foundry's .env format guidelines. Doesn't do anything if '--include-dot-env' is not set.\n    -ext, --extension: This allows you to specify additional file extensions to be included in the analysis. You can use this option multiple times to add more extensions. For example: --extra-extension .json --extra-extension .txt. By default, only .sol/.t.sol and/or foundry.toml files are uploaded.\n    Tip: The timeout option is crucial as some mutations can cause infinite loops in test execution. Set this to slightly higher than your normal test suite execution time.\n</code></pre> <p>Including env variables</p> <p>We provide the ability to pass environment variables with your solidity files. If you would like to provide <code>RPC URLs</code>, <code>API keys</code>, <code>private keys</code>, etc. You can do so by using the <code>-env</code> flag which will read these parameters from your <code>.env</code> file. You can also specify a custom filepath for your <code>env</code> file using the <code>--env-file</code> flag. Refer here for format guidelines: <code>https://book.getfoundry.sh/cheatcodes/env-string</code>.</p> <p>Note: If you do require passing <code>env variables</code> for your <code>forge</code> run, this is the recommended way to do it. We encrypt all communication of this file with an extra layer of RSA on top of the regular encryption.</p>"},{"location":"CLI/Mutation%20Testing/#mutation-operators","title":"Mutation Operators","text":"<p>Our mutation operators are directly inspired by real-world smart contract exploits. Each operator represents a pattern of change that has historically led to security incidents.</p> <p>Below is a comprehensive list of all currently supported operators.</p> <ol> <li>Arithmetic Operator Mutations:<ul> <li><code>+</code> \u2194 <code>-</code></li> <li><code>%</code> \u2194 <code>/</code></li> <li><code>-</code> \u2194 <code>+</code></li> <li><code>/</code> \u2194 <code>%</code> </li> </ul> </li> <li>Comparison Operator Mutations: Inverts comparison operators:<ul> <li><code>==</code> \u2194 <code>!=</code></li> <li><code>&gt;</code>\u2194 <code>&lt;</code></li> <li><code>&gt;=</code> \u2194 <code>&lt;</code></li> <li><code>&lt;=</code> \u2194 <code>&gt;</code></li> </ul> </li> <li>Logical Operator Mutations (AND \u2194 OR): Swaps logical operators:<ul> <li><code>&amp;&amp;</code> \u2194 <code>||</code></li> <li><code>||</code> \u2194 <code>&amp;&amp;</code></li> </ul> </li> <li>Condition Negation Mutations: Negates a condition by adding or removing the ! operator.</li> <li>Ternary Conditional Mutations: Swaps the <code>true</code> and <code>false</code> branches in a ternary expression <code>(?:)</code>.</li> <li>Function Call Mutations (<code>delegatecall</code> \u2192 <code>call</code>): Replaces <code>delegatecall</code> with <code>call</code>.</li> <li>Hex Number Literal Mutations:<ul> <li>Replaces any hex literal with <code>0x0</code>.</li> <li>Replaces a hex literal with a different randomly chosen hex literal found in the same function.</li> </ul> </li> <li>Remove emit Statement: Removes the <code>emit</code> statement.</li> <li>Remove delete Operator: Removes the <code>delete</code> statement.</li> <li>Storage Location Mutations: Swaps the variable declaration storage location:<ul> <li><code>storage</code> \u2194 <code>memory</code></li> </ul> </li> <li>Variable Assignment Operator Replacement: Swaps <code>+=</code> with <code>-=</code> (and vice versa).</li> <li>State Variable Initialization Changes: Mutates state variable initial values based on type.</li> <li>Modifier Removal Mutations: Removes function modifiers.</li> <li>Address Swap Mutations: Swaps addresses in function calls.</li> </ol>"},{"location":"CLI/Mutation%20Testing/#arithmetic-operator-mutations-1","title":"Arithmetic Operator Mutations (1)","text":"<pre><code>// Original\namount + tax\n// Mutated\namount - tax\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#comparison-operator-mutations-2","title":"Comparison Operator Mutations (2)","text":"<pre><code>// Original\namount &gt; 0\n// Mutated\namount &lt; 0\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#logical-operator-mutations-and-or-3","title":"Logical Operator Mutations (AND \u2194 OR) (3)","text":"<pre><code>// Original\nrequire(isEnabled &amp;&amp; amount &gt; 100)\n// Mutated\nrequire(isEnabled || amount &gt; 100)\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#condition-negation-mutations-4","title":"Condition Negation Mutations (4)","text":"<pre><code>// Original\nif (taxEnabled)\n// Mutated\nif (!taxEnabled)\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#ternary-conditional-mutations-5","title":"Ternary Conditional Mutations (5)","text":"<pre><code>// Original\namount &lt; 100 ? amount : 100 - tax\n// Mutated\namount &lt; 100 ? 100 - tax : amount\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#function-call-mutations-delegatecall-call-6","title":"Function Call Mutations (delegatecall \u2192 call) (6)","text":"<pre><code>// Original\n(address).delegatecall(data)\n// Mutated\n(address).call(data)\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#_1","title":"Mutation Test Generation","text":""},{"location":"CLI/Mutation%20Testing/#hex-number-literal-mutations-7","title":"Hex Number Literal Mutations (7)","text":"<pre><code>// Original\n0xabcd1234\n// Mutated 1 (\u2192 0)\n0x0\n// Mutated 2 (\u2192 Another Random Hex)\n0xdef12345\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#remove-emit-statement-8","title":"Remove emit Statement (8)","text":"<pre><code>// Original\nemit Transfer(msg.sender, recipient, amount);\n// Mutated\n// (empty string)\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#_2","title":"Mutation Test Generation","text":""},{"location":"CLI/Mutation%20Testing/#remove-delete-operator-9","title":"Remove delete Operator (9)","text":"<pre><code>// Original\ndelete myStruct;\n// Mutated\n// (empty string)\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#_3","title":"Mutation Test Generation","text":""},{"location":"CLI/Mutation%20Testing/#storage-location-mutations-10","title":"Storage Location Mutations (10)","text":"<pre><code>// Original\nuint[] storage x;\n// Mutated\nuint[] memory x;\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#variable-assignment-operator-replacement-11","title":"Variable Assignment Operator Replacement (11)","text":"<pre><code>// Original\nbalances[msg.sender] += amount;\n// Mutated\nbalances[msg.sender] -= amount;\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#state-variable-initialization-changes-12","title":"State Variable Initialization Changes (12)","text":"<pre><code>// Original\nbool public taxEnabled = true;\n// Mutated\nbool public taxEnabled = false;\n\n// Original\nuint public maxSupply = 1000;\n// Mutated\nuint public maxSupply = 1001;\n\n// Original\nstring public greeting = \"Hello\";\n// Mutated\nstring public greeting = \"Mutation text\"\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#_4","title":"Mutation Test Generation","text":""},{"location":"CLI/Mutation%20Testing/#modifier-removal-mutations-13","title":"Modifier Removal Mutations (13)","text":"<pre><code>// Original\nfunction toggleTax() public onlyOwner {\n    // ...\n}\n\n// Mutated\nfunction toggleTax() public {\n    // ...\n}\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#_5","title":"Mutation Test Generation","text":""},{"location":"CLI/Mutation%20Testing/#address-swap-mutations-14","title":"Address swap Mutations (14)","text":"<pre><code>// Original\naddress(0xaaaaaaaaaaaaaaaaaaaaa).call();\n// Mutated\naddress(0xbbbbbbbbbbbbbbbbbbbbb).call(); // where 0xbbbbbbbbbbbbbbbbbbbbb is another address in the current function\n</code></pre>"},{"location":"CLI/Mutation%20Testing/#_6","title":"Mutation Test Generation","text":""},{"location":"CLI/Mutation%20Testing/#security-foundation","title":"Security Foundation","text":"<p>Each mutation operator in this tool was carefully selected based on extensive analysis of historical smart contract exploits. By studying security incidents and identifying the precise commits that introduced vulnerabilities, we\u2019ve created a comprehensive set of mutations that represent real-world attack vectors.</p> <p>This approach ensures that your test suite is validated against realistic threat models rather than purely theoretical vulnerabilities.</p>"},{"location":"CLI/Unit%20Testing/","title":"Unit Test Generation","text":"<p>Welcome to the Olympix Unit Test Generator documentation! This guide will walk you through how to automatically generate unit tests (and even mutation tests) for your Solidity smart contracts using the Olympix CLI. Follow these steps to set up your environment and get started.</p>"},{"location":"CLI/Unit%20Testing/#overview","title":"Overview","text":"<p>The Olympix Unit Test Generator works in tandem with the Foundry toolchain to create:</p> <ul> <li>Unit tests for your contracts</li> <li>Mutation tests to assess the quality of your existing tests</li> </ul> <p>\ud83d\udca1 Tip: Running the test generator consumes Olympix credits. The credit usage details will be included in the email with your test results.</p>"},{"location":"CLI/Unit%20Testing/#prerequisites","title":"Prerequisites","text":"<p>Before running the generator, ensure you have completed the following:</p> <p>Forge Configuration</p> <ul> <li>Verify that your Forge remappings are correctly set up for your project.  </li> <li>Learn more about Forge remappings.</li> </ul>"},{"location":"CLI/Unit%20Testing/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"CLI/Unit%20Testing/#1-ensure-your-forge-remappings-are-accurate","title":"1. Ensure Your Forge Remappings Are Accurate","text":"<p>Your project must compile successfully with Forge. Double-check your remappings in the project configuration to avoid any compilation issues.</p>"},{"location":"CLI/Unit%20Testing/#2-create-olympixunittestsol","title":"2. Create <code>OlympixUnitTest.sol</code>","text":"<p>A special file named <code>OlympixUnitTest.sol</code> is required in your Foundry test directory. This file contains the base contract for your unit tests.  </p> <p>Action Required</p> <p>Copy and paste the following content into <code>OlympixUnitTest.sol</code> to set up the foundation for your tests. <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nabstract contract OlympixUnitTest {\n    constructor(string memory _name) {}\n}\n</code></pre></p>"},{"location":"CLI/Unit%20Testing/#3-create-your-unit-test-skeleton","title":"3. Create Your Unit Test Skeleton","text":"<p>For each contract you wish to test, create a unit test file that adheres to the Forge naming convention: <code>&lt;contractName&gt;.t.sol</code></p> <p>Your test skeleton should: - Import the contract you intend to test - Import the <code>OlympixUnitTest</code> contract from <code>OlympixUnitTest.sol</code> - Define any required state variables - Include a <code>setUp()</code> function to initialize the testing environment. - Any helper functions/example tests that you want the test generator to build off of.</p> <p>Note</p> <p>Good tests require a good setup function, which correctly initializes all relevant smart contracts.</p> <p>Example unit test skeleton <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../contracts/MyContract.sol\";       // Adjust the path as needed\nimport \"./OlympixUnitTest.sol\";\n\ncontract MyContractTest is OlympixUnitTest(\"MyContract\") {\n    MyContract public myContract;\n\n    // setUp() is run before each test\n    function setUp() public {\n        myContract = new MyContract();\n    }\n\n    // Example test function\n    function testExample() public {\n        // Example assertion using a helper from OlympixUnitTest\n        uint expected = 42;\n        uint actual = myContract.someFunction();\n        assertEqual(expected, actual);\n    }\n}\n</code></pre></p> <p>For a detailed example, check out this YouTube tutorial.</p>"},{"location":"CLI/Unit%20Testing/#4-run-the-unit-test-generator","title":"4. Run the Unit Test Generator","text":"<p>Navigate to the root folder of your Solidity project and execute the following command in your terminal:</p> <pre><code>olympix generate-unit-tests -w .\n</code></pre> <p>This command launches an interactive mode where you can select the contracts for which unit tests should be generated. After a brief processing period, the results will be emailed to your registered address.</p> <p>What to Expect</p> <ul> <li>Email Notification: You will receive an email containing all the generated unit tests along with statistics.</li> <li>Credit Consumption: Remember, using this feature consumes Olympix credits.</li> </ul>"},{"location":"CLI/Unit%20Testing/#5-review-and-utilize-the-results","title":"5. Review and Utilize the Results","text":"<p>Once you receive the email:</p> <ul> <li>Examine the generated unit tests.</li> <li>Integrate them into your project.</li> <li>Iterate on the tests as needed to improve coverage.</li> </ul> <p>Including env variables</p> <p>We provide the ability to pass environment variables with your solidity files. If you would like to provide <code>RPC URLs</code>, <code>API keys</code>, <code>private keys</code>, etc. You can do so by using the <code>-env</code> flag which will read these parameters from your <code>.env</code> file. You can also specify a custom filepath for your <code>env</code> file using the <code>--env-file</code> flag. Refer here for format guidelines: <code>https://book.getfoundry.sh/cheatcodes/env-string</code>.</p> <p>Note: If you do require passing <code>env variables</code> for your <code>forge</code> run, this is the recommended way to do it. We encrypt all communication of this file with an extra layer of RSA on top of the regular encryption.</p>"},{"location":"CLI/Unit%20Testing/#need-help","title":"Need Help?","text":"<p>If you encounter any issues or have questions, feel free to reach out:</p> <p>Email: contact@olympix.ai</p> <p>Happy testing! \ud83c\udf89</p>"},{"location":"Github%20Actions/integrated-security/","title":"Integrated Security","text":"<p>The Olympix Integrated Security action enables you to incorporate Olympix's vulnerability analysis directly into your GitHub workflows. This powerful integration allows you to scan your Solidity code for vulnerabilities as part of your CI process, with results reported in various formats to fit your needs. You can access this action from the Github Marketplace or visit the GitHub repository.</p>"},{"location":"Github%20Actions/integrated-security/#overview","title":"Overview","text":"<p>The Olympix Integrated Security action performs code analysis on Solidity projects, delivering detailed results in formats such as SARIF (default), JSON, and more. With this integration, you can:</p> <ul> <li>Quickly scan for vulnerabilities in your smart contracts.</li> <li>Customize scanning rules to match your project's requirements.</li> <li>Automatically upload results to GitHub Code Scanning for easy review and tracking.</li> </ul>"},{"location":"Github%20Actions/integrated-security/#features","title":"Features","text":"<ul> <li>Code Scanning: Automatically scan your GitHub repository for vulnerabilities during each workflow run.</li> <li>Detailed Results: View in-depth analysis reports directly in your GitHub workflow console or through GitHub's Code Scanning tool.</li> <li>Customizable Rules: Tailor the scanning rules using the provided inputs to exclude or focus on specific vulnerability types.</li> </ul>"},{"location":"Github%20Actions/integrated-security/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Set Up Repository Secret:</p> <ul> <li>Add a GitHub repository secret named <code>OLYMPIX_API_TOKEN</code> with your Olympix API token as the value.</li> </ul> </li> <li> <p>Configure the GitHub Action:</p> <ul> <li>Add the <code>olympix/integrated-security</code> action to your workflow file.</li> </ul> </li> <li> <p>(Optional) Customize Scanning Rules:</p> <ul> <li>Use the <code>args</code> input to pass custom options for your vulnerability scan.</li> </ul> </li> </ol>"},{"location":"Github%20Actions/integrated-security/#usage-examples","title":"Usage Examples","text":""},{"location":"Github%20Actions/integrated-security/#example-1-default-sarif-output","title":"Example 1: Default SARIF Output","text":"<p>This workflow example uses the default settings to run the analysis and upload the SARIF results to GitHub Code Scanning.</p> <pre><code>name: Integrated Security Workflow\non: push\njobs:\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Run Olympix Integrated Security\n        uses: olympix/integrated-security@main\n        env:\n          OLYMPIX_API_TOKEN: ${{ secrets.OLYMPIX_API_TOKEN }}\n      - name: Upload result to GitHub Code Scanning\n        uses: github/codeql-action/upload-sarif@v3\n        with:\n          sarif_file: olympix.sarif\n</code></pre>"},{"location":"Github%20Actions/integrated-security/#example-2-json-output-with-custom-vulnerability-exclusions","title":"Example 2: JSON Output with Custom Vulnerability Exclusions","text":"<p>In this example, the action is configured to output results in JSON format, and it excludes vulnerabilities related to uninitialized state variables and default visibility.</p> <pre><code>name: Integrated Security Workflow\non: push\njobs:\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Olympix Integrated Security\n        uses: olympix/integrated-security@main\n        env:\n          OLYMPIX_API_TOKEN: ${{ secrets.OLYMPIX_API_TOKEN }}\n        with:\n          args: -f json --no-uninitialized-state-variable --no-default-visibility\n</code></pre>"},{"location":"Github%20Actions/integrated-security/#analysis-options","title":"Analysis Options","text":"<p>When running the analysis via the integrated action, you can customize the scan using the following options:</p> <ul> <li> <p><code>-w | --workspace-path</code>   Defines the root project directory path. This provides the project context for more accurate analysis. Default: current directory</p> </li> <li> <p><code>-p | --path</code>   Specifies the Solidity project directory path to analyze. Can be repeated for multiple directories. Default: <code>contracts</code> and <code>src</code> directories if present, else the workspace directory</p> </li> <li> <p><code>-f | --output-format</code>   Sets the output format. Supported formats are <code>tree</code>, <code>json</code>, <code>sarif</code>, and <code>email</code>. Default: <code>tree</code> (or <code>sarif</code> for GitHub Code Scanning)</p> </li> <li> <p><code>-o | --output-path</code>   Defines the output directory path for the results (applicable for <code>json</code> and <code>sarif</code> formats). Default: Displays results in the terminal</p> </li> <li> <p><code>--no-&lt;vulnerability id&gt;</code>   Specifies vulnerabilities to ignore. Can be used multiple times to exclude each type. Default: No vulnerabilities are ignored</p> </li> </ul>"},{"location":"Github%20Actions/integrated-security/#support-contact","title":"Support Contact","text":"<p>If you have any questions, need feedback, or require further assistance, feel free to reach out at contact@olympix.ai.</p>"},{"location":"Github%20Actions/mutation-test-generator/","title":"Mutation Test Generation","text":"<p>The Olympix Mutation Test Generation action allows you to integrate mutation testing into your CI/CD workflows on GitHub. This action automates the creation of mutation tests for your Solidity projects, helping ensure that your existing unit tests are robust and capable of catching code mutations.</p>"},{"location":"Github%20Actions/mutation-test-generator/#overview","title":"Overview","text":"<p>The Olympix Mutation Test Generation action leverages Olympix's powerful test generator tool to run mutation tests on your smart contracts. By integrating this into your CI workflow, you can focus on developing your smart contracts while the action handles the mutation testing process during your builds.</p> <p>You can access this action from the GitHub Marketplace or visit the GitHub repository for more details.</p>"},{"location":"Github%20Actions/mutation-test-generator/#features","title":"Features","text":"<ul> <li> <p>Mutation Tests Generation: Automatically generate mutation tests to evaluate the effectiveness of your unit tests and enhance test coverage.</p> </li> <li> <p>CI/CD Integration:   Seamlessly integrate mutation testing into your GitHub workflows to continuously assess test quality.</p> </li> <li> <p>Automated Reporting:   Once the mutation tests are complete, results are emailed to the address associated with your Olympix API token, including details about which mutants were killed or survived.</p> </li> </ul>"},{"location":"Github%20Actions/mutation-test-generator/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Set Up API Token:</p> <ul> <li>Add a GitHub repository secret with your Olympix API token.</li> <li>Set an environment variable <code>OLYMPIX_API_TOKEN</code> in your workflow using this secret.</li> </ul> </li> <li> <p>Add the Mutation Test Generator Action:</p> <ul> <li>Include the <code>olympix/mutation-test-generator</code> action in your workflow.</li> </ul> </li> <li>Configure GitHub Access (Optional) (1):<ul> <li>Install the Github Notifier service to your repo. It will ask you to grant it permission to create check runs. This GitHub App enables test result reporting via GitHub Check Runs. It works seamlessly with Olympix\u2019s GitHub Actions\u2014currently supporting the Olympix Mutation Test Generator.</li> </ul> </li> </ol> <ol> <li>This allows the mutation-tester to access your private GitHub repository.</li> </ol>"},{"location":"Github%20Actions/mutation-test-generator/#usage-example","title":"Usage Example","text":"<p>Below is an example workflow that triggers on each commit containing the string <code>OPIX-GEN-MUTATION-TESTS</code>. This workflow installs the necessary dependencies with <code>npm install</code> and <code>forge install</code> , and then triggers the mutation test generator with the required paths for each target Solidity contract.</p> <pre><code>name: Mutation Test Generation Workflow\non:\n  push\n\njobs:\n  mutation-test-generation:\n    if: contains(github.event.head_commit.message, 'OPIX-GEN-MUTATION-TESTS') # Modify this.\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with: \n          submodules: recursive\n\n      - name: Install dependencies\n        run: npm install # or yarn install or bun etc. whatever your repository requires to setup before being able to call forge test.\n\n      - name: Install Foundry\n        uses: foundry-rs/foundry-toolchain@v1\n\n      - name: Run forge install \n        run: |\n          forge install\n\n      - name: Mutation Test Generator\n        uses: olympix/mutation-test-generator@main\n        env:\n          OLYMPIX_API_TOKEN: ${{ secrets.OLYMPIX_API_TOKEN }}\n          OLYMPIX_FAIL_MUTATION_GHA_THRESHOLD: 30 # optional, provides a threshold(in percentage) below which the check will fail.\n          OLYMPIX_GITHUB_COMMIT_HEAD_SHA: ${{ github.sha }} # optional, marks the commit on which the check run will appear in the repo.\n        with:\n          args: -p src/subjectContract1.sol -p src/subjectContract2.sol # Modify this: List of target contracts (we currently accept a maximum of 5 target contracts.)\n</code></pre> <p>The workflow will start, and an email with the mutation test results will be sent to the address associated with your API token. The generation time will vary based on the size and complexity of your contracts.</p>"},{"location":"Github%20Actions/mutation-test-generator/#github-app-integration","title":"Github App integration","text":"<p>If you chose to install the <code>olympix-notifier</code> GitHub app to your repository, you will receive a check run on this commit with the results as a json object. This check will fail based on the <code>OLYMPIX_GITHUB_COMMIT_HEAD_SHA</code> variable. You can choose to script on top of this check run as well. Read more here.</p>"},{"location":"Github%20Actions/unit-test-generator/","title":"Unit Test Generation","text":"<p>The Olympix Test Generation action enables you to integrate our test generator tool directly into your GitHub CI/CD workflows. By using this action, you can automatically generate unit tests for your Solidity projects, ensuring code correctness and reliability\u2014all without manually writing tests.</p>"},{"location":"Github%20Actions/unit-test-generator/#overview","title":"Overview","text":"<p>The Olympix Test Generation action performs code analysis and test generation for Solidity projects. It allows developers to focus on building robust smart contracts while the tool handles test creation during CI runs.</p> <p>You can access this action from the GitHub Marketplace or visit the GitHub repository for more details.</p>"},{"location":"Github%20Actions/unit-test-generator/#features","title":"Features","text":"<ul> <li> <p>Unit Tests Generation:   Automatically generate unit tests to help verify the functionality of your smart contracts.</p> </li> <li> <p>CI/CD Integration:   Seamlessly integrate the test generation process into your GitHub workflows.</p> </li> <li> <p>Email Notifications:   Once test generation completes, results are sent to the email address associated with your Olympix API token.</p> </li> </ul>"},{"location":"Github%20Actions/unit-test-generator/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Set Up API Token:</p> <ul> <li>Add a GitHub repository secret with your Olympix API token.</li> <li>Ensure an environment variable <code>OLYMPIX_API_TOKEN</code> is set in your workflow using the secret.</li> </ul> </li> <li> <p>Add the Test Generator Action:</p> <ul> <li>Include the <code>olympix/test-generator</code> action in your workflow.</li> </ul> </li> </ol> <p>Optional: Add Generated Tests Directly to Your Repository</p> <ol> <li> <p>Configure GitHub Access:</p> <ul> <li>Create a GitHub personal access token.</li> <li>Add a GitHub repository secret with this token.</li> <li>Set an environment variable <code>OLYMPIX_GITHUB_ACCESS_TOKEN</code> in your workflow with the secret value.</li> </ul> </li> <li> <p>Branch Setup:</p> <ul> <li>Create a branch named <code>opix-unit-test</code> where the generated tests will be committed.</li> </ul> </li> </ol>"},{"location":"Github%20Actions/unit-test-generator/#usage-examples","title":"Usage Examples","text":""},{"location":"Github%20Actions/unit-test-generator/#example-1-triggering-test-generation-on-pr-merge","title":"Example 1: Triggering Test Generation on PR Merge","text":"<p>This workflow triggers test generation whenever a pull request is merged from the <code>main</code> branch to the <code>opix-unit-test</code> branch:</p> <pre><code>name: Unit Test Generation Workflow\non:\n  pull_request:\n    types:\n      - closed\n\njobs:\n  test-generation:\n    if: github.event.pull_request.merged == true &amp;&amp; github.head_ref == 'main' &amp;&amp; github.base_ref == 'opix-unit-test'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 18.17.1\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Unit Test Generator\n        uses: olympix/test-generator@main\n        env:\n          OLYMPIX_API_TOKEN: ${{ secrets.OLYMPIX_API_TOKEN }}\n          OLYMPIX_GITHUB_ACCESS_TOKEN: ${{ secrets.OLYMPIX_GITHUB_TOKEN }}\n</code></pre>"},{"location":"Github%20Actions/unit-test-generator/#example-2-triggering-on-specific-commit-message","title":"Example 2: Triggering on Specific Commit Message","text":"<p>This example triggers the workflow on each commit that contains the string <code>OPIX-GEN-UNIT-TEST</code>. It installs dependencies, runs <code>forge install</code>, and then triggers the test generator:</p> <pre><code>name: Unit Test Generation Workflow\non:\n  push\n\njobs:\n  test-generation:\n    if: contains(github.event.head_commit.message, 'OPIX-GEN-UNIT-TEST')\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with: \n          submodules: recursive\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Install Foundry\n        uses: foundry-rs/foundry-toolchain@v1\n\n      - name: Run forge install \n        run: |\n          forge install\n\n      - name: Unit Test Generator\n        uses: olympix/test-generator@main\n        env:\n          OLYMPIX_API_TOKEN: ${{ secrets.OLYMPIX_API_TOKEN }}\n          OLYMPIX_GITHUB_ACCESS_TOKEN: ${{ secrets.OLYMPIX_GITHUB_TOKEN }}\n</code></pre> <p>Once triggered, the workflow starts the test generation process and sends the results via email. The generation time will vary depending on the size and complexity of your contracts.</p>"},{"location":"VSCode%20Extension/","title":"VSCode Extension","text":"<p>Our extension is available in the VSCode Marketplace. Install it to integrate Olympix features directly into your development environment.</p>"},{"location":"VSCode%20Extension/#features","title":"Features","text":"<p>The Olympix VSCode extension brings powerful security analysis right into your editor, helping you write more secure Solidity code.</p> <ul> <li>Real-time Vulnerability Scanning: Get immediate feedback on potential security issues as you type.</li> <li>Automatic Quick Fixes: Apply suggested code changes to fix common vulnerabilities with a single click.</li> </ul>"},{"location":"VSCode%20Extension/#quick-fixes","title":"\ud83d\udca1 Quick Fixes","text":"<p>The Olympix Quick Fix feature is designed to accelerate your development workflow by providing instant, actionable solutions to detected vulnerabilities. When our analyzer identifies a potential issue, it may also suggest a code snippet that can resolve it.</p>"},{"location":"VSCode%20Extension/#how-it-works","title":"How It Works","text":"<ol> <li>Detection: When a vulnerability is found, it will be highlighted in the \"Problems\" tab of VS Code, and a squiggle will appear under the affected code.</li> <li>Action: A lightbulb icon \ud83d\udca1 will appear next to the highlighted line. Click the icon or use the keyboard shortcut (<code>Ctrl</code>+<code>.</code> on Windows/Linux, <code>Cmd</code>+<code>.</code> on macOS).</li> <li>Apply: Select the \"Apply Olympix Quick Fix\" option from the context menu to automatically insert the suggested code change.</li> </ol>"},{"location":"VSCode%20Extension/#example-locked-ether-vulnerability","title":"Example: Locked Ether Vulnerability","text":"<p>A \"locked ether\" vulnerability occurs when a contract can receive Ether but has no function to withdraw it. Our Quick Fix feature makes resolving this simple.</p> <ol> <li> <p>Vulnerability Detected: The extension highlights the contract definition, warning that it can receive Ether but has no way to send it out, potentially locking funds permanently.</p> </li> <li> <p>Apply the Quick Fix: Clicking the lightbulb icon presents the option to apply the fix.</p> </li> <li> <p>Result: The extension automatically inserts a generic <code>withdraw</code> function into the contract. This new function contains a placeholder (<code>owner</code>) that you should replace with the correct address for withdrawal authorization.</p> </li> </ol> <p>This feature helps you fix vulnerabilities quickly and learn secure coding patterns without leaving your editor.</p>"},{"location":"VSCode%20Extension/#current-detectors-with-quick-fixes","title":"Current detectors with Quick Fixes:","text":"<ul> <li> <p><code>arbitrary-send-ether</code></p> </li> <li> <p><code>any-tx-origin</code></p> </li> <li> <p><code>arbitrary-delegatecall</code></p> </li> <li> <p><code>array-parameter-location</code></p> </li> <li> <p><code>default-visibility</code></p> </li> <li> <p><code>enum-conversion-out-of-range</code></p> </li> <li> <p><code>ether-balance-check-strict-equality</code></p> </li> <li> <p><code>locked-ether</code></p> </li> <li> <p><code>low-level-call-params-verified</code></p> </li> <li> <p><code>no-parameter-validation-in-constructor</code></p> </li> <li> <p><code>possible-division-by-zero</code></p> </li> <li> <p><code>required-tx-origin</code></p> </li> <li> <p><code>unbounded-pragma</code></p> </li> <li> <p><code>unchecked-low-level</code></p> </li> <li> <p><code>unchecked-send</code></p> </li> <li> <p><code>unchecked-token-transfer</code></p> </li> <li> <p><code>uninitialized-local-storage</code></p> </li> </ul>"}]}